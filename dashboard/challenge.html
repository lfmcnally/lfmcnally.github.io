<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Challenge - Classicalia</title>
    <link rel="icon" type="image/png" href="../images/favicon.png">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0f172a;
            min-height: 100vh;
            color: white;
            display: flex;
            flex-direction: column;
        }

        /* Loading / Error states */
        .state-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            text-align: center;
            padding: 2rem;
        }
        .state-screen h1 { font-size: 2rem; margin-bottom: 1rem; }
        .state-screen p { color: #94a3b8; font-size: 1.1rem; margin-bottom: 1.5rem; }
        .btn {
            padding: 0.75rem 1.5rem;
            border-radius: 10px;
            font-weight: 600;
            font-size: 1rem;
            cursor: pointer;
            text-decoration: none;
            transition: all 0.2s;
            border: none;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }
        .btn-primary { background: #7c3aed; color: white; }
        .btn-primary:hover { background: #6d28d9; transform: translateY(-2px); }
        .btn-lg { padding: 1rem 2.5rem; font-size: 1.2rem; border-radius: 12px; }
        .btn-ghost {
            background: rgba(255,255,255,0.1);
            color: white;
            border: 2px solid rgba(255,255,255,0.2);
        }
        .btn-ghost:hover { background: rgba(255,255,255,0.15); }

        /* Pre-challenge screen */
        #preScreen {
            background: linear-gradient(135deg, #1e1b4b 0%, #0f172a 100%);
        }
        .challenge-intro {
            max-width: 500px;
        }
        .challenge-intro-icon { font-size: 4rem; margin-bottom: 1.5rem; }
        .challenge-intro h1 { font-size: 2.5rem; margin-bottom: 0.5rem; }
        .challenge-intro .type-badge {
            display: inline-block;
            padding: 0.35rem 1rem;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 600;
            margin-bottom: 1.5rem;
        }
        .badge-speed { background: rgba(251, 191, 36, 0.2); color: #fbbf24; }
        .badge-streak { background: rgba(239, 68, 68, 0.2); color: #ef4444; }
        .badge-marathon { background: rgba(16, 185, 129, 0.2); color: #10b981; }
        .badge-gold_rush { background: rgba(251, 191, 36, 0.2); color: #fbbf24; }

        /* Chest overlay (Gold Rush) */
        .chest-overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(15, 23, 42, 0.95);
            display: none; flex-direction: column; align-items: center; justify-content: center;
            z-index: 50; padding: 2rem;
        }
        .chest-overlay.open { display: flex; }
        .chest-prompt { font-size: 1.3rem; font-weight: 700; margin-bottom: 0.5rem; color: #fbbf24; }
        .chest-subtext { font-size: 0.9rem; color: #94a3b8; margin-bottom: 2rem; }
        .chest-row { display: flex; gap: 1.5rem; }
        .chest-box {
            width: 110px; height: 110px;
            background: linear-gradient(145deg, #92400e 0%, #78350f 50%, #451a03 100%);
            border: 3px solid #d97706; border-radius: 16px;
            display: flex; align-items: center; justify-content: center;
            font-size: 3rem; cursor: pointer; transition: all 0.2s;
            animation: chest-wobble 2s ease-in-out infinite;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        .chest-box:nth-child(2) { animation-delay: 0.3s; }
        .chest-box:nth-child(3) { animation-delay: 0.6s; }
        .chest-box:hover { transform: scale(1.12); border-color: #fbbf24; box-shadow: 0 0 25px rgba(251, 191, 36, 0.3); }
        @keyframes chest-wobble {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-8px); }
        }

        /* Card reveal */
        .card-reveal {
            display: none; flex-direction: column; align-items: center; text-align: center;
            animation: card-pop 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        .card-reveal.show { display: flex; }
        @keyframes card-pop {
            0% { transform: scale(0) rotate(-10deg); opacity: 0; }
            100% { transform: scale(1) rotate(0); opacity: 1; }
        }
        .card-reveal-box {
            padding: 2rem 2.5rem; border-radius: 16px; border: 3px solid;
            min-width: 280px; max-width: 350px;
        }
        .card-reveal-box.rarity-common { border-color: #6b7280; background: rgba(107, 114, 128, 0.15); }
        .card-reveal-box.rarity-uncommon { border-color: #10b981; background: rgba(16, 185, 129, 0.1); box-shadow: 0 0 20px rgba(16, 185, 129, 0.2); }
        .card-reveal-box.rarity-rare { border-color: #3b82f6; background: rgba(59, 130, 246, 0.1); box-shadow: 0 0 25px rgba(59, 130, 246, 0.3); }
        .card-reveal-box.rarity-legendary { border-color: #fbbf24; background: rgba(251, 191, 36, 0.1); box-shadow: 0 0 30px rgba(251, 191, 36, 0.4); animation: legendary-glow 1s infinite alternate; }
        .card-reveal-box.rarity-negative { border-color: #ef4444; background: rgba(239, 68, 68, 0.1); }
        @keyframes legendary-glow {
            from { box-shadow: 0 0 20px rgba(251, 191, 36, 0.3); }
            to { box-shadow: 0 0 40px rgba(251, 191, 36, 0.6); }
        }
        .card-emoji { font-size: 3rem; margin-bottom: 0.75rem; }
        .card-text { font-size: 1rem; color: #e2e8f0; margin-bottom: 1rem; line-height: 1.4; }
        .card-points { font-size: 2rem; font-weight: 800; }
        .card-points.positive { color: #34d399; }
        .card-points.negative { color: #f87171; }
        .card-rarity-label { font-size: 0.75rem; text-transform: uppercase; letter-spacing: 2px; margin-top: 0.5rem; }

        /* Gold stat color */
        .stat-gold .stat-item-value { color: #fbbf24; }
        .challenge-details {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 1.25rem;
            margin-bottom: 2rem;
            text-align: left;
        }
        .challenge-detail-row {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }
        .challenge-detail-row:last-child { border: none; }
        .challenge-detail-label { color: #94a3b8; }
        .challenge-detail-value { font-weight: 600; }

        /* Quiz area */
        #quizScreen {
            display: none;
            flex: 1;
            padding: 0;
        }

        /* Top stats bar */
        .stats-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 2rem;
            background: rgba(255,255,255,0.05);
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        .stat-group {
            display: flex;
            gap: 2rem;
        }
        .stat-item {
            text-align: center;
        }
        .stat-item-value {
            font-size: 1.75rem;
            font-weight: 700;
            line-height: 1;
        }
        .stat-item-label {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #94a3b8;
            margin-top: 0.25rem;
        }
        .stat-score .stat-item-value { color: #a78bfa; }
        .stat-streak .stat-item-value { color: #f59e0b; }
        .stat-accuracy .stat-item-value { color: #34d399; }

        /* Timer */
        .timer-display {
            font-size: 2rem;
            font-weight: 700;
            font-variant-numeric: tabular-nums;
            padding: 0.5rem 1.5rem;
            border-radius: 12px;
            background: rgba(255,255,255,0.1);
        }
        .timer-display.warning { color: #f59e0b; background: rgba(245, 158, 11, 0.1); }
        .timer-display.danger { color: #ef4444; background: rgba(239, 68, 68, 0.15); animation: pulse-timer 0.5s infinite alternate; }
        @keyframes pulse-timer { from { opacity: 1; } to { opacity: 0.7; } }

        /* Streak fire */
        .streak-fire {
            display: none;
            font-size: 1.5rem;
            animation: flame 0.3s ease-in-out;
        }
        .streak-fire.active { display: inline; }
        @keyframes flame {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); }
            100% { transform: scale(1); }
        }

        /* Main quiz content */
        .quiz-main {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 2rem;
            max-width: 600px;
            margin: 0 auto;
            width: 100%;
        }

        /* Progress bar */
        .challenge-progress {
            width: 100%;
            height: 6px;
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
            margin-bottom: 2rem;
            overflow: hidden;
        }
        .challenge-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #7c3aed, #a78bfa);
            border-radius: 3px;
            transition: width 0.3s;
            width: 0%;
        }

        /* Word display */
        .word-display {
            text-align: center;
            margin-bottom: 2rem;
            width: 100%;
        }
        .word-label {
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: #94a3b8;
            margin-bottom: 0.75rem;
        }
        .word-text {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
            line-height: 1.2;
        }
        .word-info {
            font-size: 0.9rem;
            color: #64748b;
        }

        /* Answer input */
        .answer-area {
            width: 100%;
            max-width: 500px;
        }
        .answer-input {
            width: 100%;
            padding: 1rem 1.25rem;
            border-radius: 12px;
            border: 2px solid rgba(255,255,255,0.15);
            background: rgba(255,255,255,0.05);
            color: white;
            font-size: 1.25rem;
            text-align: center;
            outline: none;
            transition: all 0.2s;
            font-family: inherit;
        }
        .answer-input:focus {
            border-color: #7c3aed;
            background: rgba(124, 58, 237, 0.05);
            box-shadow: 0 0 0 4px rgba(124, 58, 237, 0.15);
        }
        .answer-input.correct {
            border-color: #10b981;
            background: rgba(16, 185, 129, 0.1);
        }
        .answer-input.incorrect {
            border-color: #ef4444;
            background: rgba(239, 68, 68, 0.1);
        }

        /* Feedback */
        .feedback {
            text-align: center;
            margin-top: 1rem;
            min-height: 2rem;
            font-size: 1rem;
            transition: all 0.2s;
        }
        .feedback-correct { color: #34d399; }
        .feedback-incorrect { color: #f87171; }

        /* Action buttons */
        .action-row {
            display: flex;
            gap: 1rem;
            margin-top: 1.5rem;
            width: 100%;
            max-width: 500px;
        }
        .action-row .btn { flex: 1; justify-content: center; }

        /* Results screen */
        #resultsScreen { display: none; }
        .results-card {
            max-width: 500px;
            background: rgba(255,255,255,0.05);
            border-radius: 20px;
            padding: 2.5rem;
            text-align: center;
            border: 1px solid rgba(255,255,255,0.1);
        }
        .results-icon { font-size: 4rem; margin-bottom: 1rem; }
        .results-card h1 { font-size: 2rem; margin-bottom: 0.5rem; }
        .results-card p { color: #94a3b8; margin-bottom: 2rem; }
        .results-stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
            margin-bottom: 2rem;
        }
        .result-stat {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 1rem;
        }
        .result-stat-value {
            font-size: 1.75rem;
            font-weight: 700;
            color: #a78bfa;
        }
        .result-stat-label {
            font-size: 0.8rem;
            color: #94a3b8;
            margin-top: 0.25rem;
        }

        /* Mini leaderboard on results */
        .results-leaderboard { margin-top: 1.5rem; margin-bottom: 1.5rem; width: 100%; }
        .results-leaderboard h3 { font-size: 1rem; color: #94a3b8; margin-bottom: 0.75rem; text-transform: uppercase; letter-spacing: 1px; }
        .mini-lb-row {
            display: flex; align-items: center; gap: 0.75rem; padding: 0.6rem 0.75rem;
            border-radius: 10px; margin-bottom: 0.4rem;
        }
        .mini-lb-row.rank-1 { background: linear-gradient(135deg, rgba(255,215,0,0.15), rgba(255,215,0,0.05)); }
        .mini-lb-row.rank-2 { background: linear-gradient(135deg, rgba(192,192,192,0.15), rgba(192,192,192,0.05)); }
        .mini-lb-row.rank-3 { background: linear-gradient(135deg, rgba(205,127,50,0.15), rgba(205,127,50,0.05)); }
        .mini-lb-row.is-me { border: 1px solid rgba(124, 58, 237, 0.4); }
        .mini-lb-medal { font-size: 1.3rem; width: 28px; text-align: center; flex-shrink: 0; }
        .mini-lb-avatar { font-size: 1.2rem; }
        .mini-lb-name { flex: 1; font-weight: 500; font-size: 0.9rem; text-align: left; }
        .mini-lb-tag { font-size: 0.65rem; color: #a78bfa; }
        .mini-lb-score { font-weight: 700; font-size: 1.1rem; color: #a78bfa; }
        .mini-lb-score.gold { color: #fbbf24; }

        /* Streak animation overlay */
        .streak-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            font-size: 3rem;
            font-weight: 800;
            color: #f59e0b;
            text-shadow: 0 0 30px rgba(245, 158, 11, 0.5);
            pointer-events: none;
            z-index: 100;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        .streak-popup.show {
            transform: translate(-50%, -50%) scale(1);
        }
        .streak-popup.hide {
            transform: translate(-50%, -70%) scale(0.5);
            opacity: 0;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .stats-bar { padding: 0.75rem 1rem; }
            .stat-group { gap: 1rem; }
            .stat-item-value { font-size: 1.25rem; }
            .timer-display { font-size: 1.5rem; padding: 0.4rem 1rem; }
            .word-text { font-size: 1.75rem; }
            .answer-input { font-size: 1.1rem; }
            .results-stats { grid-template-columns: 1fr 1fr; }
            .chest-box { width: 90px; height: 90px; font-size: 2.5rem; }
            .chest-row { gap: 1rem; }
            .card-reveal-box { min-width: 240px; padding: 1.5rem; }
        }
    </style>
</head>
<body>

    <!-- Pre-Challenge Screen -->
    <div id="preScreen" class="state-screen">
        <div class="challenge-intro">
            <div class="challenge-intro-icon" id="introIcon">‚ö°</div>
            <h1 id="introTitle">Loading...</h1>
            <div class="type-badge badge-speed" id="introTypeBadge">Speed Round</div>
            <div class="challenge-details" id="introDetails">
                <div class="challenge-detail-row">
                    <span class="challenge-detail-label">Loading...</span>
                    <span class="challenge-detail-value">...</span>
                </div>
            </div>
            <button class="btn btn-primary btn-lg" id="startBtn" onclick="startChallenge()" style="display: none;">
                Start Challenge
            </button>
            <p id="preMessage" style="color: #94a3b8; font-size: 0.9rem; margin-top: 1rem;"></p>
        </div>
    </div>

    <!-- Quiz Screen -->
    <div id="quizScreen">
        <!-- Stats Bar -->
        <div class="stats-bar">
            <div class="stat-group">
                <div class="stat-item stat-score">
                    <div class="stat-item-value" id="statScore">0</div>
                    <div class="stat-item-label">Score</div>
                </div>
                <div class="stat-item stat-streak">
                    <div class="stat-item-value">
                        <span id="statStreak">0</span>
                        <span class="streak-fire" id="streakFire">üî•</span>
                    </div>
                    <div class="stat-item-label">Streak</div>
                </div>
                <div class="stat-item stat-accuracy">
                    <div class="stat-item-value" id="statAccuracy">0%</div>
                    <div class="stat-item-label">Accuracy</div>
                </div>
            </div>
            <div class="timer-display" id="timerDisplay">5:00</div>
        </div>

        <!-- Quiz Content -->
        <div class="quiz-main">
            <div class="challenge-progress">
                <div class="challenge-progress-fill" id="progressFill"></div>
            </div>

            <div class="word-display">
                <div class="word-label" id="wordLabel">Translate this word</div>
                <div class="word-text" id="wordText">‚Äî</div>
                <div class="word-info" id="wordInfo"></div>
            </div>

            <div class="answer-area">
                <input type="text" class="answer-input" id="answerInput" placeholder="Type your answer..." autocomplete="off" autocapitalize="off" spellcheck="false">
                <div class="feedback" id="feedback"></div>
                <div class="action-row">
                    <button class="btn btn-primary" id="checkBtn" onclick="checkAnswer()">Check</button>
                    <button class="btn btn-ghost" id="skipBtn" onclick="skipWord()">Skip</button>
                    <button class="btn btn-primary" id="nextBtn" onclick="nextWord()" style="display: none;">Next</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Results Screen -->
    <div id="resultsScreen" class="state-screen">
        <div class="results-card">
            <div class="results-icon" id="resultsIcon">üèÜ</div>
            <h1 id="resultsTitle">Challenge Complete!</h1>
            <p id="resultsMessage">Great effort!</p>
            <div class="results-stats" id="resultsStats"></div>
            <div class="results-leaderboard" id="resultsLeaderboard" style="display: none;">
                <h3>Leaderboard</h3>
                <div id="resultsLeaderboardBody"></div>
            </div>
            <a href="student.html" class="btn btn-primary btn-lg">Back to Dashboard</a>
        </div>
    </div>

    <!-- Streak Popup -->
    <div class="streak-popup" id="streakPopup"></div>

    <!-- Chest Overlay (Gold Rush) -->
    <div class="chest-overlay" id="chestOverlay">
        <div class="chest-prompt" id="chestPrompt">Choose a chest!</div>
        <div class="chest-subtext" id="chestSubtext">+10 gold for the correct answer</div>
        <div class="chest-row" id="chestRow">
            <div class="chest-box" onclick="openChest(0)">üéÅ</div>
            <div class="chest-box" onclick="openChest(1)">üéÅ</div>
            <div class="chest-box" onclick="openChest(2)">üéÅ</div>
        </div>
        <div class="card-reveal" id="cardReveal">
            <div class="card-reveal-box" id="cardRevealBox">
                <div class="card-emoji" id="cardEmoji">ü™ô</div>
                <div class="card-text" id="cardText">Found some coins!</div>
                <div class="card-points" id="cardPoints">+10</div>
                <div class="card-rarity-label" id="cardRarity">Common</div>
            </div>
        </div>
    </div>

    <script src="../auth/config.js"></script>
    <script src="../shared/vocabulary-data.js"></script>
    <script src="../shared/greek-vocabulary-data.js"></script>
    <script src="../latin/data/suburani-vocab.js"></script>
    <script src="../shared/xp-system.js"></script>
    <script>
        // ========== LENIENT ANSWER CHECKING (from vocabulary-quiz.js) ==========
        function levenshteinDistance(str1, str2) {
            const m = str1.length, n = str2.length;
            const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));
            for (let i = 0; i <= m; i++) dp[i][0] = i;
            for (let j = 0; j <= n; j++) dp[0][j] = j;
            for (let i = 1; i <= m; i++) {
                for (let j = 1; j <= n; j++) {
                    if (str1[i-1] === str2[j-1]) dp[i][j] = dp[i-1][j-1];
                    else dp[i][j] = 1 + Math.min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]);
                }
            }
            return dp[m][n];
        }

        function normalizeText(text) {
            return text.toLowerCase().replace(/\.{2,}/g, ' ').replace(/[-‚Äì‚Äî]/g, ' ').replace(/\s+/g, ' ').replace(/['']/g, "'").trim();
        }

        function removeSpacesAndDashes(text) {
            return text.toLowerCase().replace(/[-‚Äì‚Äî\s.]/g, '');
        }

        function removeCommonPrefixes(text) {
            return text.replace(/^(to |i |a |an |the )/, '').replace(/^(he\/she\/it |he |she |it )/, '').replace(/^(we |you |they )/, '').trim();
        }

        function isCloseMatch(userAnswer, correctAnswer) {
            if (userAnswer === correctAnswer) return true;
            const allowedDistance = correctAnswer.length >= 8 ? 2 : (correctAnswer.length >= 4 ? 1 : 0);
            return levenshteinDistance(userAnswer, correctAnswer) <= allowedDistance;
        }

        function isAnswerCorrect(userAnswer, correctAnswer) {
            const userNorm = normalizeText(userAnswer);
            const correctNorm = normalizeText(correctAnswer);
            const acceptableAnswers = correctNorm.split(/[,;\/]/).map(a => a.trim()).filter(a => a.length > 0);
            acceptableAnswers.push(correctNorm);

            for (const acceptable of acceptableAnswers) {
                const withoutParens = acceptable.replace(/\([^)]*\)/g, '').trim().replace(/\s+/g, ' ');
                const variations = [acceptable, withoutParens, removeCommonPrefixes(acceptable), removeCommonPrefixes(withoutParens)];
                const userVariations = [userNorm, removeCommonPrefixes(userNorm)];

                for (const correctVar of variations) {
                    if (!correctVar) continue;
                    for (const userVar of userVariations) {
                        if (userVar === correctVar) return true;
                        if (isCloseMatch(userVar, correctVar)) return true;
                        if (removeSpacesAndDashes(userVar) === removeSpacesAndDashes(correctVar)) return true;
                        const correctWords = correctVar.split(' ').filter(w => w.length > 2);
                        for (const word of correctWords) {
                            if (isCloseMatch(userVar, word)) return true;
                        }
                    }
                }
            }
            return false;
        }
        // ========== END ANSWER CHECKING ==========

        // ========== GOLD RUSH: CHANCE CARDS ==========
        const BASE_GOLD = 10;
        let goldTotal = 0;
        let goldRushCorrect = 0;
        let pendingCard = null;
        let chestOpen = false;

        const CHANCE_CARDS = [
            // Common positive (~35%)
            { text: "A few coins from the forum.", points: 5, rarity: 'common', emoji: 'ü™ô' },
            { text: "A merchant tips you for good Latin.", points: 10, rarity: 'common', emoji: 'üè™' },
            { text: "Found coins in a Roman bath!", points: 10, rarity: 'common', emoji: 'üèõÔ∏è' },
            { text: "Pocket change from a centurion.", points: 5, rarity: 'common', emoji: 'ü™ñ' },
            { text: "Small bounty from the Senate.", points: 15, rarity: 'common', emoji: 'üèõÔ∏è' },
            { text: "A grateful farmer shares his wealth.", points: 10, rarity: 'common', emoji: 'üåæ' },
            // Uncommon positive (~18%)
            { text: "Caesar is impressed by your knowledge!", points: 25, rarity: 'uncommon', emoji: 'üëë' },
            { text: "You discovered a hidden mosaic!", points: 20, rarity: 'uncommon', emoji: 'üé®' },
            { text: "A senator rewards your wisdom!", points: 30, rarity: 'uncommon', emoji: 'üèõÔ∏è' },
            { text: "Found treasure in the Colosseum!", points: 25, rarity: 'uncommon', emoji: 'üèüÔ∏è' },
            { text: "The gods smile upon you!", points: 20, rarity: 'uncommon', emoji: '‚ö°' },
            // Rare positive (~7%)
            { text: "Roman treasure hoard discovered!", points: 50, rarity: 'rare', emoji: 'üíé' },
            { text: "The Oracle of Delphi blesses you!", points: 50, rarity: 'rare', emoji: 'üîÆ' },
            { text: "You won the chariot race!", points: 50, rarity: 'rare', emoji: 'üèá' },
            // Legendary (~2%)
            { text: "You've conquered Gaul!", points: 100, rarity: 'legendary', emoji: '‚öîÔ∏è' },
            // Negative (~38%) - roughly 1 in 3 chests
            { text: "Mr McNally took too long marking your prep.", points: -5, rarity: 'negative', emoji: 'üìù' },
            { text: "A pickpocket strikes in the forum!", points: -10, rarity: 'negative', emoji: 'üòà' },
            { text: "You insulted a gladiator by accident.", points: -15, rarity: 'negative', emoji: '‚öîÔ∏è' },
            { text: "The tax collector found you!", points: -10, rarity: 'negative', emoji: 'üí∏' },
            { text: "Vesuvius erupts nearby!", points: -20, rarity: 'negative', emoji: 'üåã' },
            { text: "Your toga was stolen at the baths.", points: -5, rarity: 'negative', emoji: 'üò∞' },
            { text: "You tripped in the amphitheatre.", points: -10, rarity: 'negative', emoji: 'ü§ï' },
            { text: "Barbarians raided your stash!", points: -15, rarity: 'negative', emoji: 'üó°Ô∏è' },
            { text: "Your homework ate the dog.", points: -10, rarity: 'negative', emoji: 'üêï' },
            { text: "Nero fiddled while your gold burned.", points: -20, rarity: 'negative', emoji: 'üéª' },
            { text: "You forgot to revise for the test.", points: -5, rarity: 'negative', emoji: 'üìñ' },
            { text: "A Roman goose chased you!", points: -10, rarity: 'negative', emoji: 'ü™ø' },
        ];

        function pickChanceCard() {
            const roll = Math.random() * 100;
            let pool;
            if (roll < 32) pool = CHANCE_CARDS.filter(c => c.rarity === 'common');       // 32%
            else if (roll < 50) pool = CHANCE_CARDS.filter(c => c.rarity === 'uncommon'); // 18%
            else if (roll < 57) pool = CHANCE_CARDS.filter(c => c.rarity === 'rare');     // 7%
            else if (roll < 60) pool = CHANCE_CARDS.filter(c => c.rarity === 'legendary');// 3%
            else pool = CHANCE_CARDS.filter(c => c.rarity === 'negative');                 // 40%
            return pool[Math.floor(Math.random() * pool.length)];
        }

        function showChestSelection() {
            chestOpen = true;
            document.getElementById('chestRow').style.display = 'flex';
            document.getElementById('cardReveal').classList.remove('show');
            document.getElementById('chestPrompt').textContent = 'Choose a chest!';
            document.getElementById('chestSubtext').textContent = `+${BASE_GOLD} gold for the correct answer`;
            document.getElementById('chestOverlay').classList.add('open');
            pendingCard = pickChanceCard();
        }

        function openChest(idx) {
            if (!pendingCard) return;
            const card = pendingCard;
            pendingCard = null;

            // Hide chests, show card
            document.getElementById('chestRow').style.display = 'none';
            document.getElementById('chestPrompt').textContent = '';
            document.getElementById('chestSubtext').textContent = '';

            const reveal = document.getElementById('cardReveal');
            const box = document.getElementById('cardRevealBox');

            document.getElementById('cardEmoji').textContent = card.emoji;
            document.getElementById('cardText').textContent = card.text;

            const pointsText = card.points > 0 ? `+${card.points}` : `${card.points}`;
            document.getElementById('cardPoints').textContent = `${pointsText} gold`;
            document.getElementById('cardPoints').className = `card-points ${card.points >= 0 ? 'positive' : 'negative'}`;

            const rarityLabels = { common: 'Common', uncommon: 'Uncommon', rare: 'Rare', legendary: 'LEGENDARY', negative: 'Bad Luck' };
            const rarityColors = { common: '#9ca3af', uncommon: '#34d399', rare: '#60a5fa', legendary: '#fbbf24', negative: '#f87171' };
            document.getElementById('cardRarity').textContent = rarityLabels[card.rarity];
            document.getElementById('cardRarity').style.color = rarityColors[card.rarity];

            box.className = `card-reveal-box rarity-${card.rarity}`;
            reveal.classList.add('show');

            // Apply gold from card
            goldTotal += card.points;
            if (goldTotal < 0) goldTotal = 0;
            score = goldTotal;
            updateStats();
            debouncedSave();

            // Auto-close after delay
            const delay = card.rarity === 'legendary' ? 2500 : card.rarity === 'rare' ? 2000 : 1500;
            setTimeout(() => {
                document.getElementById('chestOverlay').classList.remove('open');
                reveal.classList.remove('show');
                chestOpen = false;
                if (challengeActive) showNextWord();
            }, delay);
        }
        // ========== END GOLD RUSH ==========

        // State
        let currentUser = null;
        let challenge = null;
        let attemptId = null;
        let words = [];
        let currentWordIndex = 0;
        let currentWord = null;
        let score = 0;
        let totalQuestions = 0;
        let currentStreak = 0;
        let bestStreak = 0;
        let wordsMastered = 0;
        let wordMastery = {}; // for marathon mode
        let timerInterval = null;
        let timeRemaining = 0;
        let timeSpent = 0;
        let startTime = null;
        let challengeActive = false;
        let saveDebounce = null;

        const MASTERY_THRESHOLD = 2; // for marathon mode

        const urlParams = new URLSearchParams(window.location.search);
        const challengeId = urlParams.get('id');

        if (!challengeId) {
            document.getElementById('preScreen').innerHTML = '<div class="state-screen"><h1>No challenge specified</h1><p>This link is missing a challenge ID.</p><a href="student.html" class="btn btn-primary">Back to Dashboard</a></div>';
        }

        async function init() {
            const { data: { user } } = await supabase.auth.getUser();
            if (!user) { window.location.href = '../auth/login.html'; return; }

            const { data: profile } = await supabase
                .from('users')
                .select('*')
                .eq('id', user.id)
                .single();

            if (!profile) { window.location.href = '../auth/login.html'; return; }
            currentUser = profile;

            // Load challenge
            const { data: ch, error } = await supabase
                .from('challenges')
                .select('*, classes(name, type)')
                .eq('id', challengeId)
                .single();

            if (error || !ch) {
                document.getElementById('introTitle').textContent = 'Challenge not found';
                document.getElementById('introIcon').textContent = '‚ùå';
                document.getElementById('introDetails').innerHTML = '<p style="color: #94a3b8;">This challenge may have been deleted.</p>';
                document.getElementById('introTypeBadge').style.display = 'none';
                return;
            }

            challenge = ch;

            // Check if challenge has ended
            if (!ch.is_active || ch.status === 'ended') {
                document.getElementById('introTitle').textContent = ch.title;
                document.getElementById('introIcon').textContent = 'üèÅ';
                document.getElementById('introDetails').innerHTML = '<p style="color: #94a3b8; text-align: center;">This challenge has ended.</p>';
                document.getElementById('introTypeBadge').textContent = 'Ended';
                document.getElementById('introTypeBadge').className = 'type-badge';
                document.getElementById('introTypeBadge').style.background = 'rgba(255,255,255,0.1)';
                document.getElementById('introTypeBadge').style.color = '#94a3b8';
                return;
            }

            // Check if student already has an attempt
            const { data: existingAttempt } = await supabase
                .from('challenge_attempts')
                .select('*')
                .eq('challenge_id', challengeId)
                .eq('student_id', currentUser.id)
                .single();

            if (existingAttempt && existingAttempt.completed) {
                showResults(existingAttempt);
                return;
            }

            // Register the student as joined (create attempt record so teacher sees them)
            if (!existingAttempt) {
                await supabase.from('challenge_attempts').insert({
                    challenge_id: challengeId,
                    student_id: currentUser.id,
                    score: 0,
                    total_questions: 0,
                    best_streak: 0,
                    time_spent_seconds: 0,
                    words_mastered: 0,
                    completed: false
                });
            }

            // If challenge is still waiting for teacher to press Start
            if (ch.status === 'waiting') {
                setupWaitingScreen(ch);
                return;
            }

            // Challenge is active - go to pre-screen
            setupPreScreen(ch);
        }

        // Waiting room - polls for teacher to press Start
        let waitingInterval = null;
        let waitingSubscription = null;

        function setupWaitingScreen(ch) {
            const typeIcons = { speed: '‚ö°', streak: 'üî•', marathon: 'üèÅ', gold_rush: 'üéÅ' };
            document.getElementById('introIcon').textContent = typeIcons[ch.challenge_type] || 'üèÜ';
            document.getElementById('introTitle').textContent = ch.title;
            document.getElementById('introTypeBadge').textContent = 'Waiting for teacher to start...';
            document.getElementById('introTypeBadge').className = 'type-badge';
            document.getElementById('introTypeBadge').style.background = 'rgba(251, 191, 36, 0.2)';
            document.getElementById('introTypeBadge').style.color = '#fbbf24';

            document.getElementById('introDetails').innerHTML = `
                <div style="text-align: center; padding: 1rem;">
                    <div style="font-size: 2rem; margin-bottom: 0.5rem; animation: pulse-dot 1.5s infinite;">‚è≥</div>
                    <p style="color: #94a3b8;">You're in! Waiting for your teacher to start the challenge...</p>
                    <p style="color: #64748b; font-size: 0.8rem; margin-top: 0.5rem;">The challenge will begin automatically when the teacher presses Start.</p>
                </div>
            `;

            document.getElementById('startBtn').style.display = 'none';
            document.getElementById('preMessage').textContent = '';

            // Subscribe to challenge changes (status update)
            waitingSubscription = supabase
                .channel(`waiting-${challengeId}`)
                .on('postgres_changes',
                    { event: 'UPDATE', schema: 'public', table: 'challenges', filter: `id=eq.${challengeId}` },
                    (payload) => {
                        if (payload.new.status === 'active') {
                            if (waitingSubscription) { waitingSubscription.unsubscribe(); waitingSubscription = null; }
                            challenge.status = 'active';
                            setupPreScreen(challenge);
                        }
                    }
                )
                .subscribe();

            // Also poll as fallback (in case realtime misses it)
            waitingInterval = setInterval(async () => {
                const { data } = await supabase.from('challenges').select('status').eq('id', challengeId).single();
                if (data && data.status === 'active') {
                    clearInterval(waitingInterval);
                    if (waitingSubscription) { waitingSubscription.unsubscribe(); waitingSubscription = null; }
                    challenge.status = 'active';
                    setupPreScreen(challenge);
                }
            }, 3000);
        }

        function setupPreScreen(ch) {
            const typeIcons = { speed: '‚ö°', streak: 'üî•', marathon: 'üèÅ', gold_rush: 'üéÅ' };
            const typeNames = { speed: 'Speed Round', streak: 'Streak Challenge', marathon: 'Marathon', gold_rush: 'Gold Rush' };
            const typeBadges = { speed: 'badge-speed', streak: 'badge-streak', marathon: 'badge-marathon', gold_rush: 'badge-gold_rush' };

            document.getElementById('introIcon').textContent = typeIcons[ch.challenge_type] || 'üèÜ';
            document.getElementById('introTitle').textContent = ch.title;
            document.getElementById('introTypeBadge').textContent = typeNames[ch.challenge_type];
            document.getElementById('introTypeBadge').className = `type-badge ${typeBadges[ch.challenge_type]}`;

            // Load words
            loadWords(ch);

            let detailsHtml = '';
            detailsHtml += `<div class="challenge-detail-row"><span class="challenge-detail-label">Class</span><span class="challenge-detail-value">${ch.classes?.name || 'Unknown'}</span></div>`;
            detailsHtml += `<div class="challenge-detail-row"><span class="challenge-detail-label">Chapters</span><span class="challenge-detail-value">${ch.chapters.join(', ')}</span></div>`;
            detailsHtml += `<div class="challenge-detail-row"><span class="challenge-detail-label">Words</span><span class="challenge-detail-value">${words.length}</span></div>`;

            if (ch.challenge_type === 'gold_rush') {
                detailsHtml += `<div class="challenge-detail-row"><span class="challenge-detail-label">Time Limit</span><span class="challenge-detail-value">${Math.floor(ch.time_limit_seconds / 60)} minutes</span></div>`;
                detailsHtml += `<div class="challenge-detail-row"><span class="challenge-detail-label">Goal</span><span class="challenge-detail-value">Earn gold by answering + open chests for bonus!</span></div>`;
            } else if (ch.challenge_type === 'speed') {
                detailsHtml += `<div class="challenge-detail-row"><span class="challenge-detail-label">Time Limit</span><span class="challenge-detail-value">${Math.floor(ch.time_limit_seconds / 60)} minutes</span></div>`;
                detailsHtml += `<div class="challenge-detail-row"><span class="challenge-detail-label">Goal</span><span class="challenge-detail-value">Most correct answers wins</span></div>`;
            } else if (ch.challenge_type === 'streak') {
                detailsHtml += `<div class="challenge-detail-row"><span class="challenge-detail-label">Goal</span><span class="challenge-detail-value">Longest consecutive correct streak</span></div>`;
            } else {
                detailsHtml += `<div class="challenge-detail-row"><span class="challenge-detail-label">Goal</span><span class="challenge-detail-value">Master every word (${MASTERY_THRESHOLD}x correct each), fastest time wins</span></div>`;
            }

            document.getElementById('introDetails').innerHTML = detailsHtml;
            document.getElementById('startBtn').style.display = 'inline-flex';
            document.getElementById('preMessage').textContent = 'Your teacher has started the challenge - press Start when ready!';
        }

        function loadWords(ch) {
            let vocabData;
            if (ch.language === 'greek') {
                vocabData = typeof greekVocabularyData !== 'undefined' ? greekVocabularyData : [];
            } else if (ch.language === 'prep-latin') {
                vocabData = typeof suburaniVocabularyData !== 'undefined' ? suburaniVocabularyData : [];
            } else {
                vocabData = typeof vocabularyData !== 'undefined' ? vocabularyData : [];
            }

            words = vocabData.filter(w => ch.chapters.includes(w.chapter));

            if (ch.word_from && ch.word_to) {
                words = words.slice(ch.word_from - 1, ch.word_to);
            } else if (ch.word_from) {
                words = words.slice(ch.word_from - 1);
            } else if (ch.word_to) {
                words = words.slice(0, ch.word_to);
            }

            // Shuffle
            for (let i = words.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [words[i], words[j]] = [words[j], words[i]];
            }
        }

        function getWordKey() {
            return challenge.language === 'greek' ? 'greek' : 'latin';
        }

        // Start the challenge
        async function startChallenge() {
            if (words.length === 0) {
                alert('No words available for this challenge.');
                return;
            }

            // Create attempt record
            const { data: attempt, error } = await supabase
                .from('challenge_attempts')
                .upsert({
                    challenge_id: challengeId,
                    student_id: currentUser.id,
                    score: 0,
                    total_questions: 0,
                    best_streak: 0,
                    time_spent_seconds: 0,
                    words_mastered: 0,
                    completed: false,
                    started_at: new Date().toISOString()
                }, { onConflict: 'challenge_id,student_id' })
                .select()
                .single();

            if (error) {
                console.error('Error creating attempt:', error);
                alert('Error starting challenge. Please try again.');
                return;
            }

            attemptId = attempt.id;
            startTime = Date.now();
            challengeActive = true;

            // Initialize marathon mastery tracking
            if (challenge.challenge_type === 'marathon') {
                wordMastery = {};
                for (const w of words) {
                    wordMastery[w[getWordKey()]] = 0;
                }
            }

            // Gold Rush init
            if (challenge.challenge_type === 'gold_rush') {
                goldTotal = 0;
                goldRushCorrect = 0;
                score = 0;
                // Change stat labels for gold mode
                const scoreItem = document.querySelector('.stat-score');
                scoreItem.classList.add('stat-gold');
                scoreItem.querySelector('.stat-item-label').textContent = 'Gold';
            }

            // Setup timer
            if ((challenge.challenge_type === 'speed' || challenge.challenge_type === 'gold_rush') && challenge.time_limit_seconds) {
                timeRemaining = challenge.time_limit_seconds;
                startTimer();
            } else {
                // Count up for streak and marathon
                timeSpent = 0;
                startCountUpTimer();
            }

            // Show quiz
            document.getElementById('preScreen').style.display = 'none';
            document.getElementById('quizScreen').style.display = 'flex';

            // Hide timer for streak mode (we still track time but don't show countdown)
            if (challenge.challenge_type === 'streak') {
                document.getElementById('timerDisplay').style.display = 'block';
            }

            showNextWord();
            document.getElementById('answerInput').focus();
        }

        function startTimer() {
            updateTimerDisplay();
            timerInterval = setInterval(() => {
                timeRemaining--;
                timeSpent++;
                updateTimerDisplay();

                if (timeRemaining <= 0) {
                    clearInterval(timerInterval);
                    endChallenge();
                }
            }, 1000);
        }

        function startCountUpTimer() {
            updateCountUpDisplay();
            timerInterval = setInterval(() => {
                timeSpent++;
                updateCountUpDisplay();
            }, 1000);
        }

        function updateTimerDisplay() {
            const display = document.getElementById('timerDisplay');
            const mins = Math.floor(timeRemaining / 60);
            const secs = timeRemaining % 60;
            display.textContent = `${mins}:${secs.toString().padStart(2, '0')}`;

            display.classList.remove('warning', 'danger');
            if (timeRemaining <= 10) display.classList.add('danger');
            else if (timeRemaining <= 30) display.classList.add('warning');
        }

        function updateCountUpDisplay() {
            const display = document.getElementById('timerDisplay');
            const mins = Math.floor(timeSpent / 60);
            const secs = timeSpent % 60;
            display.textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // Show the next word
        function showNextWord() {
            if (!challengeActive) return;

            if (challenge.challenge_type === 'marathon') {
                // Pick an unmastered word
                const unmastered = words.filter(w => wordMastery[w[getWordKey()]] < MASTERY_THRESHOLD);
                if (unmastered.length === 0) {
                    endChallenge();
                    return;
                }
                currentWord = unmastered[Math.floor(Math.random() * unmastered.length)];
            } else {
                // Cycle through words, reshuffle when done
                if (currentWordIndex >= words.length) {
                    currentWordIndex = 0;
                    for (let i = words.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [words[i], words[j]] = [words[j], words[i]];
                    }
                }
                currentWord = words[currentWordIndex];
                currentWordIndex++;
            }

            const key = getWordKey();
            document.getElementById('wordText').textContent = currentWord[key];
            document.getElementById('wordInfo').textContent = currentWord.info || '';
            document.getElementById('wordLabel').textContent = challenge.language === 'greek' ? 'Translate this Greek word' : 'Translate this Latin word';

            // Reset input
            const input = document.getElementById('answerInput');
            input.value = '';
            input.className = 'answer-input';
            input.disabled = false;
            input.focus();

            document.getElementById('feedback').textContent = '';
            document.getElementById('feedback').className = 'feedback';
            document.getElementById('checkBtn').style.display = 'inline-flex';
            document.getElementById('skipBtn').style.display = 'inline-flex';
            document.getElementById('nextBtn').style.display = 'none';

            // Update progress for marathon
            if (challenge.challenge_type === 'marathon') {
                const total = words.length;
                const mastered = Object.values(wordMastery).filter(v => v >= MASTERY_THRESHOLD).length;
                document.getElementById('progressFill').style.width = `${(mastered / total) * 100}%`;
            }
        }

        // Check answer
        function checkAnswer() {
            if (!challengeActive || !currentWord) return;

            const input = document.getElementById('answerInput');
            const userAnswer = input.value.trim();
            if (!userAnswer) return;

            const correct = isAnswerCorrect(userAnswer, currentWord.english);
            totalQuestions++;

            const feedback = document.getElementById('feedback');

            if (correct) {
                score++;
                currentStreak++;
                if (currentStreak > bestStreak) bestStreak = currentStreak;

                input.className = 'answer-input correct';
                feedback.textContent = `Correct! "${currentWord.english}"`;
                feedback.className = 'feedback feedback-correct';

                // Marathon mastery
                if (challenge.challenge_type === 'marathon') {
                    const key = getWordKey();
                    wordMastery[currentWord[key]]++;
                    if (wordMastery[currentWord[key]] === MASTERY_THRESHOLD) {
                        wordsMastered++;
                        feedback.textContent += ' - MASTERED!';
                    }
                }

                // Streak animations
                document.getElementById('streakFire').classList.toggle('active', currentStreak >= 3);
                if (currentStreak > 0 && currentStreak % 5 === 0) {
                    showStreakPopup(currentStreak);
                }
            } else {
                currentStreak = 0;
                input.className = 'answer-input incorrect';
                feedback.innerHTML = `Incorrect. Answer: <strong>"${currentWord.english}"</strong>`;
                feedback.className = 'feedback feedback-incorrect';
                document.getElementById('streakFire').classList.remove('active');

                // Marathon: reset mastery for this word
                if (challenge.challenge_type === 'marathon') {
                    const key = getWordKey();
                    const wasMastered = wordMastery[currentWord[key]] >= MASTERY_THRESHOLD;
                    wordMastery[currentWord[key]] = 0;
                    if (wasMastered) wordsMastered--;
                }
            }

            // Gold Rush: add base gold for correct answer
            if (challenge.challenge_type === 'gold_rush' && correct) {
                goldRushCorrect++;
                goldTotal += BASE_GOLD;
                score = goldTotal;
            }

            updateStats();
            input.disabled = true;

            // Show next button
            document.getElementById('checkBtn').style.display = 'none';
            document.getElementById('skipBtn').style.display = 'none';
            document.getElementById('nextBtn').style.display = 'inline-flex';

            // Save progress (debounced)
            debouncedSave();

            // Gold Rush: show chest after correct answer, auto-advance after wrong
            if (challenge.challenge_type === 'gold_rush') {
                if (correct) {
                    setTimeout(() => {
                        if (challengeActive) showChestSelection();
                    }, 500);
                } else {
                    setTimeout(() => {
                        if (challengeActive) nextWord();
                    }, 1200);
                }
                return;
            }

            // For speed mode, auto-advance after brief delay
            if (challenge.challenge_type === 'speed') {
                setTimeout(() => {
                    if (challengeActive) nextWord();
                }, correct ? 600 : 1200);
            }
        }

        function skipWord() {
            if (!challengeActive || !currentWord || chestOpen) return;
            totalQuestions++;
            currentStreak = 0;
            document.getElementById('streakFire').classList.remove('active');

            const feedback = document.getElementById('feedback');
            feedback.innerHTML = `Skipped. Answer: <strong>"${currentWord.english}"</strong>`;
            feedback.className = 'feedback feedback-incorrect';

            updateStats();
            debouncedSave();

            setTimeout(() => { if (challengeActive) showNextWord(); }, 800);
        }

        function nextWord() {
            if (!challengeActive || chestOpen) return;
            showNextWord();
        }

        function updateStats() {
            if (challenge && challenge.challenge_type === 'gold_rush') {
                document.getElementById('statScore').textContent = goldTotal;
                document.getElementById('statStreak').textContent = currentStreak;
                const accuracy = totalQuestions > 0 ? Math.round((goldRushCorrect / totalQuestions) * 100) : 0;
                document.getElementById('statAccuracy').textContent = accuracy + '%';
            } else {
                document.getElementById('statScore').textContent = score;
                document.getElementById('statStreak').textContent = currentStreak;
                const accuracy = totalQuestions > 0 ? Math.round((score / totalQuestions) * 100) : 0;
                document.getElementById('statAccuracy').textContent = accuracy + '%';
            }
        }

        function showStreakPopup(streak) {
            const popup = document.getElementById('streakPopup');
            popup.textContent = `üî• ${streak} STREAK!`;
            popup.className = 'streak-popup show';
            setTimeout(() => { popup.className = 'streak-popup hide'; }, 1200);
            setTimeout(() => { popup.className = 'streak-popup'; }, 1500);
        }

        // Save progress to database
        async function saveProgress() {
            if (!attemptId) return;

            const elapsed = Math.floor((Date.now() - startTime) / 1000);

            await supabase
                .from('challenge_attempts')
                .update({
                    score: score,
                    total_questions: totalQuestions,
                    best_streak: bestStreak,
                    time_spent_seconds: elapsed,
                    words_mastered: wordsMastered
                })
                .eq('id', attemptId);
        }

        function debouncedSave() {
            if (saveDebounce) clearTimeout(saveDebounce);
            // Save quickly so teacher's live scoreboard updates promptly
            saveDebounce = setTimeout(saveProgress, 200);
        }

        // End challenge
        async function endChallenge() {
            if (!challengeActive) return;
            challengeActive = false;
            clearInterval(timerInterval);

            const elapsed = Math.floor((Date.now() - startTime) / 1000);

            // Final save
            const { data } = await supabase
                .from('challenge_attempts')
                .update({
                    score: score,
                    total_questions: totalQuestions,
                    best_streak: bestStreak,
                    time_spent_seconds: elapsed,
                    words_mastered: wordsMastered,
                    completed: true,
                    completed_at: new Date().toISOString()
                })
                .eq('id', attemptId)
                .select()
                .single();

            showResults(data || {
                score, total_questions: totalQuestions, best_streak: bestStreak,
                time_spent_seconds: elapsed, words_mastered: wordsMastered
            });
        }

        function showResults(attempt) {
            document.getElementById('preScreen').style.display = 'none';
            document.getElementById('quizScreen').style.display = 'none';
            document.getElementById('resultsScreen').style.display = 'flex';

            const isGoldRushResult = challenge && challenge.challenge_type === 'gold_rush';
            const accuracy = attempt.total_questions > 0
                ? Math.round(((isGoldRushResult ? goldRushCorrect : attempt.score) / attempt.total_questions) * 100)
                : 0;

            if (accuracy >= 90) {
                document.getElementById('resultsIcon').textContent = 'üåü';
                document.getElementById('resultsTitle').textContent = 'Outstanding!';
                document.getElementById('resultsMessage').textContent = 'Incredible performance!';
            } else if (accuracy >= 70) {
                document.getElementById('resultsIcon').textContent = 'üèÜ';
                document.getElementById('resultsTitle').textContent = 'Great Job!';
                document.getElementById('resultsMessage').textContent = 'Solid effort!';
            } else {
                document.getElementById('resultsIcon').textContent = 'üí™';
                document.getElementById('resultsTitle').textContent = 'Challenge Complete!';
                document.getElementById('resultsMessage').textContent = 'Keep practising - you\'ll get there!';
            }

            const mins = Math.floor(attempt.time_spent_seconds / 60);
            const secs = attempt.time_spent_seconds % 60;
            const timeStr = `${mins}:${secs.toString().padStart(2, '0')}`;

            const isGoldRush = challenge && challenge.challenge_type === 'gold_rush';

            let statsHtml = '';
            if (isGoldRush) {
                statsHtml += `
                    <div class="result-stat" style="grid-column: span 2;">
                        <div class="result-stat-value" style="color: #fbbf24; font-size: 2.5rem;">${attempt.score}</div>
                        <div class="result-stat-label">Total Gold</div>
                    </div>
                `;
            }
            statsHtml += `
                <div class="result-stat">
                    <div class="result-stat-value">${isGoldRush ? goldRushCorrect : attempt.score}</div>
                    <div class="result-stat-label">Correct Answers</div>
                </div>
                <div class="result-stat">
                    <div class="result-stat-value">${accuracy}%</div>
                    <div class="result-stat-label">Accuracy</div>
                </div>
                <div class="result-stat">
                    <div class="result-stat-value">${attempt.best_streak}</div>
                    <div class="result-stat-label">Best Streak</div>
                </div>
                <div class="result-stat">
                    <div class="result-stat-value">${timeStr}</div>
                    <div class="result-stat-label">Time</div>
                </div>
            `;

            if (challenge && challenge.challenge_type === 'marathon') {
                statsHtml += `
                    <div class="result-stat" style="grid-column: span 2;">
                        <div class="result-stat-value">${attempt.words_mastered}</div>
                        <div class="result-stat-label">Words Mastered</div>
                    </div>
                `;
            }

            document.getElementById('resultsStats').innerHTML = statsHtml;

            // Fetch and show top 3 leaderboard
            loadResultsLeaderboard();
        }

        async function loadResultsLeaderboard() {
            if (!challenge) return;
            const challengeId = new URLSearchParams(window.location.search).get('id');

            // Fetch all attempts for this challenge
            const { data: attempts } = await supabase
                .from('challenge_attempts')
                .select('*')
                .eq('challenge_id', challengeId);

            if (!attempts || attempts.length === 0) return;

            // Fetch user profiles
            const studentIds = [...new Set(attempts.map(a => a.student_id))];
            const { data: users } = await supabase
                .from('users')
                .select('id, full_name, selected_emoji, selected_tag')
                .in('id', studentIds);

            const userMap = {};
            if (users) users.forEach(u => { userMap[u.id] = u; });

            // Sort by challenge type
            let sorted;
            const ct = challenge.challenge_type;
            if (ct === 'speed' || ct === 'gold_rush') {
                sorted = [...attempts].sort((a, b) => b.score - a.score || a.time_spent_seconds - b.time_spent_seconds);
            } else if (ct === 'streak') {
                sorted = [...attempts].sort((a, b) => b.best_streak - a.best_streak || b.score - a.score);
            } else {
                sorted = [...attempts].sort((a, b) => {
                    if (a.completed && !b.completed) return -1;
                    if (!a.completed && b.completed) return 1;
                    if (a.completed && b.completed) return a.time_spent_seconds - b.time_spent_seconds;
                    return (b.words_mastered || 0) - (a.words_mastered || 0);
                });
            }

            const top3 = sorted.slice(0, 3);
            const medals = ['ü•á', 'ü•à', 'ü•â'];
            const isGR = ct === 'gold_rush';

            const body = document.getElementById('resultsLeaderboardBody');
            body.innerHTML = top3.map((a, i) => {
                const u = userMap[a.student_id];
                const name = u?.full_name || 'Student';
                const emoji = u?.selected_emoji || 'üôÇ';
                const tagId = u?.selected_tag;
                const tagInfo = tagId && typeof xpSystem !== 'undefined' ? xpSystem.TAGS?.find(t => t.id === tagId) : null;
                const tagHtml = tagInfo ? `<div class="mini-lb-tag">${tagInfo.emoji} ${tagInfo.text}</div>` : '';
                const isMe = currentUser && a.student_id === currentUser.id;

                let scoreDisplay;
                if (isGR) scoreDisplay = `ü™ô ${a.score}`;
                else if (ct === 'streak') scoreDisplay = `üî• ${a.best_streak}`;
                else if (ct === 'marathon') scoreDisplay = a.completed ? formatMiniTime(a.time_spent_seconds) : `${a.words_mastered || 0} words`;
                else scoreDisplay = a.score;

                return `
                    <div class="mini-lb-row rank-${i + 1}${isMe ? ' is-me' : ''}">
                        <div class="mini-lb-medal">${medals[i]}</div>
                        <div class="mini-lb-avatar">${emoji}</div>
                        <div class="mini-lb-name">${isMe ? 'You' : name.split(' ')[0]}${tagHtml}</div>
                        <div class="mini-lb-score${isGR ? ' gold' : ''}">${scoreDisplay}</div>
                    </div>`;
            }).join('');

            document.getElementById('resultsLeaderboard').style.display = 'block';
        }

        function formatMiniTime(seconds) {
            if (!seconds) return '‚Äî';
            const m = Math.floor(seconds / 60);
            const s = seconds % 60;
            return `${m}:${s.toString().padStart(2, '0')}`;
        }

        // Enter key to submit
        document.getElementById('answerInput').addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                if (chestOpen) return; // Don't advance while chest is showing
                if (document.getElementById('nextBtn').style.display !== 'none') {
                    nextWord();
                } else {
                    checkAnswer();
                }
            }
        });

        init();
    </script>
</body>
</html>
